package skills

import (
	"context"
	"fmt"

	server "github.com/inference-gateway/adk/server"
{{- range $depID := .Inject }}
{{- if eq $depID "logger" }}
	"go.uber.org/zap"
{{- else }}
	{{ $depID | toCamelCase }} "{{ $.GoModule }}/internal/{{ $depID | toSnakeCase }}"
{{- end }}
{{- end }}
)

// {{ .Name | toPascalCase }}Skill struct holds the skill with dependencies
type {{ .Name | toPascalCase }}Skill struct {
{{- range $depID := .Inject }}
{{- if eq $depID "logger" }}
	{{ $depID | toCamelCase }} *zap.Logger
{{- else }}
{{- $dep := index $.DependencyMap $depID }}
	{{ $depID | toCamelCase }} {{ $depID | toCamelCase }}.{{ $dep.Name }}
{{- end }}
{{- end }}
}

// New{{ .Name | toPascalCase }}Skill creates a new {{ .Name }} skill
func New{{ .Name | toPascalCase }}Skill({{ range $index, $depID := .Inject }}{{ if $index }}, {{ end }}{{- if eq $depID "logger" }}{{ $depID | toCamelCase }} *zap.Logger{{- else }}{{- $dep := index $.DependencyMap $depID }}{{ $depID | toCamelCase }} {{ $depID | toCamelCase }}.{{ $dep.Name }}{{- end }}{{ end }}) server.Tool {
	skill := &{{ .Name | toPascalCase }}Skill{
{{- range $depID := .Inject }}
		{{ $depID | toCamelCase }}: {{ $depID | toCamelCase }},
{{- end }}
	}
	return server.NewBasicTool(
		"{{ .Name }}",
		"{{ .Description }}",
		map[string]any{
			"type": "object",
			"properties": map[string]any{
				{{- range $key, $value := .Schema.properties }}
				"{{ $key }}": map[string]any{
					{{- range $k, $v := $value }}
					{{- if eq $k "enum" }}
					"{{ $k }}": []string{ {{- range $i, $e := $v }}{{ if $i }}, {{ end }}"{{ $e }}"{{ end -}} },
					{{- else if eq $k "required" }}
					"{{ $k }}": []string{ {{- range $i, $e := $v }}{{ if $i }}, {{ end }}"{{ $e }}"{{ end -}} },
					{{- else if eq $k "properties" }}
					"{{ $k }}": {{ $v | toGoMap }},
					{{- else if eq $k "items" }}
					"{{ $k }}": {{ $v | toGoMap }},
					{{- else }}
					"{{ $k }}": {{ $v | toJson }},
					{{- end }}
					{{- end }}
				},
				{{- end }}
			},
			{{- if .Schema.required }}
			"required": []string{ {{- range $i, $field := .Schema.required }}{{ if $i }}, {{ end }}"{{ $field }}"{{ end -}} },
			{{- end }}
		},
		skill.{{ .Name | toPascalCase }}Handler,
	)
}

// {{ .Name | toPascalCase }}Handler handles the {{ .Name }} skill execution
func (s *{{ .Name | toPascalCase }}Skill) {{ .Name | toPascalCase }}Handler(ctx context.Context, args map[string]any) (string, error) {
	// TODO: Implement {{ .Name }} logic
	// {{ .Description }}

	// Example of using dependencies:
	{{- range $depID := .Inject }}
	// s.{{ $depID | toCamelCase }}.SomeMethod(ctx, ...)
	{{- end }}
	
	// Extract parameters from args
	{{- range $key, $value := .Schema.properties }}
	{{- if eq $value.type "string" }}
	// {{ $key }} := args["{{ $key }}"].(string)
	{{- else if eq $value.type "number" }}
	// {{ $key }} := args["{{ $key }}"].(float64)
	{{- else if eq $value.type "integer" }}
	// {{ $key }} := args["{{ $key }}"].(int)
	{{- else if eq $value.type "boolean" }}
	// {{ $key }} := args["{{ $key }}"].(bool)
	{{- else }}
	// {{ $key }} := args["{{ $key }}"]
	{{- end }}
	{{- end }}
	
	return fmt.Sprintf(`{"result": "TODO: Implement {{ .Name }} logic", "input": %+v}`, args), nil
}
